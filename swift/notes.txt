UIKit is Apple's native user interface toolkit. It contains things like buttons, text boxes, navigation controls and more, and you drive it using Swift.

AppKit is Apple’s native user interface toolkit for macOS. Like UIKit it contains things like buttons, text boxes, and more, although focused on macOS rather than iOS.

SwiftUI is a cross-platform toolkit that lets us build apps for iOS, macOS, tvOS, and watchOS.
Cocoa Touch is the name commonly used for Apple's vast collection of frameworks for iOS. It includes 
UIKit to do user interfaces, but most people would say it also includes SpriteKit for making 2D games, SceneKit for making 3D games, MapKit for maps, Core Graphics for drawing, Core Animation for animating things, and much more.

Cocoa is the name used for Apple’s framework collection on macOS. Strictly speaking it’s made up of 

AppKit for user interface, Foundation for basic functionality, and Core Data for object graphs, but like Cocoa Touch it’s often used to mean “all of macOS development.”

Playgrounds are miniature Swift testing environments that let you type code and see the results immediately. You don't build real apps with them, but they are great for learning.


`var` for variable declarations

`let` for constant declarations



you can declare and define a variable at once

`var name = "Maya"`

`var age = 5`

or use a type annotation

`var name: String`

`var age: Int`

`var age: Int = 3`



basic types are String, Int, Float, Double, Bool

Double has higher accuracy than Float



string interpolation

var name = "Maya"

"Your name is \(name)"



arrays use type inference and can be declared un-typed

`var evenNumbers = [2, 4, 6, 8]

type(of: evenNumbers)`

=> Array<Int>.Type



they can also be declared with types

`var songs: [String] = ["Shake it Off", "You Belong with Me", "Back to December"]

var songs: [Any] = ["Shake it Off", "You Belong with Me", "Back to December", 3]

var songs: [String] = []

var songs = [String]()`



ranges inclusive ...

`for i in 1...10 {

    print("\(i) x 10 is \(i * 10)")

}`

ranges exclusive ..<



to range through an array

`for song in songs {

    print(song)

}



for i in 0..<people.count {

    print(song)

}`



switch case statements do not fall through

`var val = 2

switch val {

case 0:

case 1:

case 2:

    print("got a match")

default:

}



switch val {

case 0..>2:

case 2:

    print("got a match")

default:

}`



`func favoriteAlbum(name: String) {

    print("My favorite album is \(name)")

}



favoriteAlbum(name: "Fearless")`



you can use different internal and external parameter names for functions by declaring the variable twice

`func countLettersInString(external internal: String) {

    print("internal handle \(internal)")

}

countLettersInString(external: "Hello")



func countLettersInString(_ internal: String) {

    print("internal handle \(internal)")

}



countLettersInString("Hello")



func countLetters(in str: String) {

print("internal handle \(str)")

}

countLetters(in: "Hello")`



return values

`func albumIsTaylors(name: String) -> Bool {

    if name == "Fearless" { return true  }

    return false

}`



optionals might have a value or might not

`func getStatus(weather: String) -> String? {

    if weather == "sunny" { return nil }

    return "good"

}



var status: String?

status = getStatus(weather: "rainy")`



optional unwrapping checks if an optional has a value, and if so, it unwraps that into a non-optional type and then runs code block

`if let unwrappedStatus = status {

    // unwrappedStatus contains a non-optional string

} else {

     // it's an optional

}`



you can overwrite optional safety by using !, if you know an optional definitely has a value

`func yearAlbumReleased(name: String) -> Int? {

    if name == "Fearless" { return 2008 }

    return nil

}



var year = yearAlbumReleased(name: "Fearless")

if year == nil {

    print("There was an error")

} else {

    print("It was released in \(year)")

}`

=> It was released in Optional(2008)

to force unwrap the value (e.g. if you've already nil-checked), use

`print("It was released in \(year!)")`



implicitly unwrapped optionals

`var name: String = "Paul"

var name2: String? = "Bob"

var name3: String! = "Sophie"`

name2 must be unwrapped to be used, name3 does not have to be unwrapped



optional chaining

`let album = albumReleased(year: 2006)?.uppercased()`

chained optionals will be checked left to right until it finds a nil at which point it stops



nil coalescing operator `??`

`let album = albumReleased(year: 2006) ?? "unknown"`

if the return val is nil, it will return "unknown"



`enum WeatherType {

    case sun

    case cloud

    case rain

    case wind

    case snow

}



func getHaterStatus(weather: WeatherType) -> String? {

    if weather == .sun {

        return nil

    } else {

        return "Hate"

    }

}`

Swift uses type inference, knowing that weather var is a WeatherType object, so can identify it using just `.sun`



`func getHaterStatus(weather: WeatherType) -> String? {

    switch weather {

    case .sun:

        return nil

    case .cloud, .wind:

        return "dislike"

    }

}`

above will fail to compile because it does not cover all cases in the enum - either add cases for wind, snow, etc. or a default case to build



attach optional values to enum values and check in a case switch

`enum WeatherType {

case sun

case cloud

case rain

case wind(speed: Int)

case snow

}



func getHaterStatus(weather: WeatherType) -> String? {

    switch weather {

    case .sun:

        return nil

    case .wind(let speed) where speed < 10:

        return "meh"

    case .cloud, .wind:

        return "dislike"

    default:

        return nil

    }

}`



member-wise initializers are automatically created when you define a struct

`struct Person {

    var clothes: String

    var shoes: String

}



let taylor = Person(clothes: "T-shirts", shoes: "sneakers")`



copies of structs created like so

`let taylor = Person(clothes: "T-shirts", shoes: "sneakers")

var taylorCopy = taylor`

are copied by value not reference



classes do not get automatic member-wise initializers as structs do

classes can inherit from other classes

when you create an instance of a class it's called and object, and when you copy that object, they are copied by reference

`class Person {

    var clothes: String

    var shoes: String



    init(clothes: String, shoes: String) {

        self.clothes = clothes

        self.shoes = shoes

    }



    func sing() {

         print("la la")

    }

}`

all non-optional values must have a value by the end of its initializer



`class Singer: Person {

    override func sing() {

        print("different la la")

    }    

}`



`class HeavyMetalSinger: Singer {

    var noiseLevel: Int



    init(name: String, age: String, noseLevel: Int) {

        self.noiseLevel = noiseLevel

        super.init(name: name, age: age)

    }

}`



if you need to make a function or class available for iOS to call, mark it with the attribute objc

`@objc func sing() {}`



two property observers, `willSet` which gives you a `newValue` handle and `didSet` which gives you an `oldValue` handle, which are called before or after a property is changed

`struct Person {

    var clothes: String {

        willSet {

            updateUI(msg: "I'm changing from \(clothes) to \(newValue)")

        }

    }

}`



computed properties can be accessed as properties but do a calculation at the time they're called, similar to functions

`struct Person {

    var age: Int

    

    var ageInDogYears: Int {

        get {

            return age * 7

        }

    }

}



var fan = Person(age: 25)

print(fan.ageInDogYears)`



static properties and methods belong to the type rather than an instance



access control

public - anyone can read and write property

internal - only your Swift code can read and write

fileprivate - only Swift code in same file

private - property is available only to methods defined on the type



typecasting

`for album in allAlbums {

    let studioAlbum = album as? StudioAlbum

}`

if typecast worked, you have a cast obj, otherwise nil



a closure is a variable that can hold lines of swift code



protocols - interface contract



Extensions let us modify Swift’s data types to add new functionality

protocol extensions let us define implementations of things inside the protocol, adding the functionality to all types that conform to the protocol in a single place.



Swift’s solution is to let us create protocol extensions: extensions that modify several data types at once.

You’ve already seen how the self keyword lets us refer to our current value, so self * self means “multiply my current number by itself.” Well, there’s also Self with a capital S, which has a subtly different meaning: it means “my current data type.” So, self means “my current value” and Self means “my current data type.”



If we want clamp() to apply to all types of integer, we can’t very well make it return Int - that’s not big enough to hold the full range of a UInt64, so Swift will refuse to build. Instead, we need to make the method return Self, which means “I’ll return whatever data type I was used with.”

Here’s the rewritten extension:

extension BinaryInteger {
    func clamp(low: Self, high: Self) -> Self {
        if (self > high) {
            return high
        } else if (self < low) {
            return low
        }

        return self
    }
}
Protocol extensions are helpful for providing default method implementations so that conforming types don’t need to implement those methods themselves unless they specifically want to.

As an example, we might define an extension for our Employee protocol so that all conforming types automatically get a doWork() method:

protocol Employee {
    var name: String { get set }
    var jobTitle: String { get set }
    func doWork()
}

extension Employee {
    func doWork() {
        print("I'm busy!")
    }
}

If you have large numbers, Swift lets you use underscores as thousands separators – they don’t change the number, but they do make it easier to read. For example:

var population = 8_000_000

If you want multi-line strings you need slightly different syntax: start and end with three double quote marks, like this:

var str1 = """
This goes
over multiple
lines
"""
the opening and closing triple must be on their own line, but opening and closing line breaks won’t be included in your final string.

If you only want multi-line strings to format your code neatly, and you don’t want those line breaks to actually be in your string, end each line with a \, like this:

var str2 = """
This goes \
over multiple \
lines
"""

Tuples allow you to store several values together in a single value. That might sound like arrays, but tuples are different:

You can’t add or remove items from a tuple; they are fixed in size.
You can’t change the type of items in a tuple; they always have the same types they were created with.
You can access items in a tuple using numerical positions or by naming them, but Swift won’t let you read numbers or names that don’t exist.

Tuples are created by placing multiple items into parentheses, like this:

var name = (first: "Taylor", last: "Swift")
You then access items using numerical positions starting from 0:

name.0
Or you can access items using their names:

name.first
Remember, you can change the values inside a tuple after you create it, but not the types of values. So, if you tried to change name to be (first: "Justin", age: 25) you would get an error.

But if we tried reading the favorite ice cream for Charlotte, we’d get back nil, meaning that Swift doesn’t have a value for that key:

giving the dictionary a default value of “Unknown”, so that when no ice cream is found for Charlotte we get back “Unknown” rather than nil:
favoriteIceCream["Charlotte", default: "Unknown"]

you can create an empty array to store integers like this:

var results = [Int]()
The exception is creating an empty set, which is done differently:

var words = Set<String>()
var numbers = Set<Int>()
This is because Swift has special syntax only for dictionaries and arrays; other types must use angle bracket syntax like sets.

If you wanted, you could create arrays and dictionaries with similar syntax:

var scores = Dictionary<String, Int>()
var results = Array<Int>()

we might define an enum that stores various kinds of activities:

enum Activity {
    case bored
    case running
    case talking
    case singing
}
That lets us say that someone is talking, but we don’t know what they are talking about, or we can know that someone is running, but we don’t know where they are running to.

Enum associated values let us add those additional details:

enum Activity {
    case bored
    case running(destination: String)
    case talking(topic: String)
    case singing(volume: Int)
}
Now we can be more precise – we can say that someone is talking about football:

let talking = Activity.talking(topic: "football")

Swift supports operator overloading, which is a fancy way of saying that what an operator does depends on the values you use it with. For example, + sums integers like this:

let meaningOfLife = 42
let doubleMeaning = 42 + 42
But + also joins strings, like this:

let fakers = "Fakers gonna "
let action = fakers + "fake"
You can even use + to join arrays, like this:

let firstHalf = ["John", "Paul"]
let secondHalf = ["George", "Ringo"]
let beatles = firstHalf + secondHalf
Remember, Swift is a type-safe language, which means it won’t let you mix types. For example, you can’t add an integer to a string because it doesn’t make any sense.

The third way of writing loops is not commonly used, but it’s so simple to learn we might as well cover it: it’s called the repeat loop, and it’s identical to a while loop except the condition to check comes at the end.

So, we could rewrite our hide and seek example like this:

var number = 1

repeat {
    print(number)
    number += 1
} while number <= 20

print("Ready or not, here I come!")
Because the condition comes at the end of the repeat loop the code inside the loop will always be executed at least once, whereas while loops check their condition before their first run.

outerLoop: for i in 1...10 {
    for j in 1...10 {
        let product = i * j
        print ("\(i) * \(j) is \(product)")
    }
}
Second, add our condition inside the inner loop, then use break outerLoop to exit both loops at the same time:

outerLoop: for i in 1...10 {
    for j in 1...10 {
        let product = i * j
        print ("\(i) * \(j) is \(product)")

        if product == 50 {
            print("It's a bullseye!")
            break outerLoop
        }
    }
}

You might have noticed that we don’t actually send any parameter names when we call print() – we say print("Hello") rather than print(message: "Hello").

You can get this same behavior in your own functions by using an underscore, _, for your external parameter name, like this:

func greet(_ person: String) {
    print("Hello, \(person)!")
}

You can make any parameter variadic by writing ... after its type. So, an Int parameter is a single integer, whereas Int... is zero or more integers – potentially hundreds.

Inside the function, Swift converts the values that were passed in to an array of integers, so you can loop over them as needed.


